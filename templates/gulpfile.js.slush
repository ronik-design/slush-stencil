var Gulp = require('gulp'),
    Util = require('gulp-util'),
    AwsPublish = require('gulp-awspublish'),
    Webpack = require('webpack'),
    ReactTools = require('react-tools'),
    Fs = require('fs'),
    runSequence = require('run-sequence'),
    exec = require('child_process').exec,
    watch = require('gulp-watch'),
    iconfont = require('gulp-iconfont'),
    size = require('gulp-size'),
    changed = require('gulp-changed'),
    imagemin = require('gulp-imagemin'),
    stylus = require('gulp-stylus'),
    nib = require('nib'),
    jeet = require('jeet'),
    rupture = require('rupture'),
    s3Website = require('s3-website'),
    argv = require('minimist')(process.argv.slice(2));

var BUCKET = 'qa.<%= domain %>';
var WEBHOOK_DOMAIN = '<%= nameWebhook %>.webhook.org';

var DEST = './static';
var RELEASE = !!argv.release;
var src = {};
var watching = false;

Gulp.task('assets', function () {
    src.assets = 'assets/**/*';
    return Gulp.src(src.assets)
        .pipe(Gulp.dest(DEST + '/'));
});

Gulp.task('styles', function() {
    src.styles = 'styles/**/*.{css,styl}';
    Gulp.src('styles/**/[!_]*.{css,styl}')
        .pipe(stylus({
            use: [nib(), jeet(), rupture()]
        }))
        .pipe(Gulp.dest(DEST + '/css/'));
});

Gulp.task('scripts', function(cb) {
    var started = false;
    var config = require('./webpack.config.js')(RELEASE, DEST);
    var bundler = Webpack(config);

    function bundle(err, stats) {
        if (err) {
            throw new Util.PluginError('webpack', err);
        }

        if (stats.hasErrors()) {
            var errs = stats.toJson().errors;

            errs.forEach(function (err) {
                console.error(err);
            });

            throw new Util.PluginError('webpack', 'You\'ve got lint!');
        }

        if (stats.hasWarnings()) {
            var warnings = stats.toJson().warnings;

            warnings.forEach(function (warn) {
                console.warn(warn);
            });

            throw new Util.PluginError('webpack', 'You\'ve got lint!');
        }

        if (argv.verbose) {
            Util.log('[webpack]', stats.toString({
                colors: true
            }));
        }

        if (!started) {
            started = true;
            return cb();
        }
    }

    if (watching) {
        bundler.watch(200, bundle);
    } else {
        bundler.run(bundle);
    }
});

Gulp.task('images', function() {
    src.images = 'images/**/*';
    return Gulp.src(src.images)
        .pipe(changed(DEST + '/images'))
        .pipe(imagemin({
            progressive: true,
            interlaced: true
        }))
        .pipe(Gulp.dest(DEST + '/images'))
        .pipe(size({
            title: 'images'
        }));
});

Gulp.task('icons', function() {
    src.icons = 'icons/*.svg';

    return Gulp.src(src.icons)
        .pipe(iconfont({
            fontName: 'iconfont',
            appendCodepoints: true
        }))
        .on('codepoints', function(codepoints, options) {
            var len = codepoints.length;
            var str = 'icons = {';
            codepoints.forEach(function (icon, idx) {
                str += '"' + icon.name + '":' + (icon.codepoint).toString(16);
                if (idx < len - 1) {
                    str += ',';
                }
            });
            str += '}';
            Fs.writeFileSync('./icons/icons.styl', str);
        })
        .pipe(Gulp.dest(DEST + '/fonts'));
});

Gulp.task('build', ['icons', 'styles', 'images', 'scripts', 'assets']);

Gulp.task('watch', function(cb) {
    watching = true;

    runSequence('build', function () {
        watch(src.assets, function() { Gulp.start('assets'); });
        watch(src.styles, function() { Gulp.start('styles'); });
        watch(src.images, function() { Gulp.start('images'); });
        watch(src.icons, function() { Gulp.start('icons'); });
        cb();
    });
});

// Starts the webhook serve process, and captures stdout
Gulp.task('serve', ['watch'], function() {
    exec('wh serve').stdout.pipe(process.stdout);
});

Gulp.task('wh-build', ['build'], function (cb) {
    var whBuild = exec('wh build');
    whBuild.stdout.pipe(process.stdout);
    whBuild.on('exit', cb);
});

Gulp.task('wh-deploy', ['build'], function () {
    var whDeploy = exec('wh deploy');
    whDeploy.stdout.pipe(process.stdout);
    whDeploy.on('exit', cb);
});

Gulp.task('s3-deploy', ['wh-build', 's3-deploy-config'], function() {
    var publisher = AwsPublish.create({ bucket: BUCKET });
    var headers = {
      'Cache-Control': 'max-age=315360000, no-transform, public'
    };

    return Gulp.src('.build/**/*')
        .pipe(AwsPublish.gzip())
        .pipe(publisher.publish(headers))
        .pipe(publisher.sync())
        .pipe(publisher.cache())
        .pipe(AwsPublish.reporter());
});

Gulp.task('s3-deploy-config', function (cb) {
    var s3Config = {
        domain: BUCKET,
        index: 'index.html',
        routes: [{
            Condition: {
                KeyPrefixEquals: 'webhook-uploads/'
            },
            Redirect: {
                HostName: WEBHOOK_DOMAIN
            }
        }]
    };

    s3Website(s3Config, function(err, website) {
        if (website.modified) {
            Util.log('[deploy-s3-config]', 'Site configuration updated %s', website.url);
        }
        cb(err);
    });
});

Gulp.task('deploy', ['wh-deploy']);

Gulp.task('deploy-s3', ['s3-deploy']);

Gulp.task('default', ['serve']);
